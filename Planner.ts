///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="StateGraph.ts"/>

/**
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter.
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations : Interpreter.InterpretationResult[], currentState : WorldState) : PlannerResult[] {
        var errors : Error[] = [];
        var plans : PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result : PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch(err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan : string[];
    }

    export function stringify(result : PlannerResult) : string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions

    /**
     * The core planner function. The code here is just a template;
     * you should rewrite this function entirely. In this template,
     * the code produces a dummy plan which is not connected to the
     * argument `interpretation`, but your version of the function
     * should be such that the resulting plan depends on
     * `interpretation`.
     *
     *
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */
    function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
        // This function returns a dummy plan involving a random stack
        var graph : StateGraph = new StateGraph(state.objects)
        var startNode : StateNode = new StateNode(state.stacks)
        var isGoal = (n:StateNode) => goalFunction(interpretation, n)
        console.log(isGoal, JSON.stringify(interpretation,null,2))
        var arm : number = state.arm
        var holding : string = state.holding
        if (holding) {
            startNode.addHolding(holding)
        }
        var shouldHold : string

        // TODO - come up with good heuristic
        //var h = (n: StateNode) => 0;
        var h = (n: StateNode) => heuristic(interpretation, n)

        var path = aStarSearch(graph, startNode, isGoal, h, 10).path
        var plan : string[] = [];

        path.forEach((s) => {
            console.log(s.toString())
        })

        if (holding) {
            path.shift()
            planPutDownHolding(path[0])
        }
        for (var i = 0; i < path.length-1; i++) {
            planBetweenStates(path[i], path[i+1])
        }
        if (shouldHold) {
            pickUpObj(path[path.length-1])
        }

        return plan;

        function heuristic(interp : Interpreter.DNFFormula, n : StateNode) : number {
            var h = Infinity
            interp.forEach((conjuction : Interpreter.Literal[]) => {
                var conjuctionHeuristic = 0
                conjuction.forEach((lit : Interpreter.Literal) => {
                    conjuctionHeuristic = conjuctionHeuristic + literalHeuristic(lit, n)
                })
                h = Math.min(h, conjuctionHeuristic)
            })
            console.log(h, n.toString())
            return h
        }

        function literalHeuristic(lit : Interpreter.Literal, n : StateNode) : number {
            var hueristic = 0
            if(lit.relation == "holding") {
                var a = findObjPos(lit.args[0], n) 
                return n.data[a[0]].length - a[1] - 1               
            }
            var a = findObjPos(lit.args[0], n)
            var b = findObjPos(lit.args[1], n)
            var aObj = lit.args[0]
            var bObj = lit.args[1]
            var isFloor = bObj == "floor"
            if (a[0] == -1 || a[1] == -1 || ((bObj && !isFloor)
                                             && (b[0] == -1 || b[1] == -1))) {
                return Infinity
            }
            var objsAboveA = n.data[a[0]].length - a[1] - 1
            var objsAboveB = n.data[b[0]].length - b[1] - 1

            switch (lit.relation) {
                case "holding":
                    hueristic = objsAboveA
                    break
                    //Objects over the object we want to move + objets over the object we want to move to
                case "ontop":
                case "inside":
                    hueristic = objsAboveA + objsAboveB + 1
                    if (a[0] == b[0] && a[1] == b[1] + 1) {
                        hueristic = 0;
                    }
                    break
                case "under":
                    hueristic = objecsToMoveInStack(bObj, n.data[a[0]]) + objsAboveB
                    if(a[0] == b[0]) {
                        hueristic--
                    }
                    break
                case "above":
                    hueristic = objecsToMoveInStack(aObj, n.data[b[0]]) + objsAboveA
                    if(a[0] == b[0]) {
                        hueristic--
                    }
                    break
                case "beside":
                    var left  = hueristicLeftOf(aObj, bObj, a[0], b[0])
                    var right = hueristicRightOf(aObj, bObj, a[0], b[0])
                    hueristic = Math.min(left,right)
                    break
                case "leftof":
                    //a left of b
                    hueristic = hueristicLeftOf(aObj, bObj, a[0], b[0])
                    break
                case "rightof":
                    hueristic = hueristicRightOf(aObj, bObj, a[0], b[0])
                    break
            }
            return hueristic

            function hueristicLeftOf(o1: string, o2: string, stackNbr1 : number, stackNbr2 : number) : number {
                //Objects over a + objects we have to move left of b
                var moveA = Infinity
                var moveB = Infinity   
                if(stackNbr1 == stackNbr2 - 1) {
                    moveA = 0
                }
                else if(stackNbr2 == stackNbr1 + 1) {
                    moveB = 0
                }
                else if (stackNbr2 - 1 >= 0) {   
                    moveA = objsAboveA + objecsToMoveInStack(o1, n.data[stackNbr2 - 1])
                }
                //Objects over b + objects we have to move left of a
                else if (stackNbr1 + 1 < n.data.length) {    
                    moveB = objsAboveB + objecsToMoveInStack(o2, n.data[stackNbr1 + 1])
                }

                //return the best value if it is easier to move a or b
                return Math.min(moveA, moveB)
            }

            function hueristicRightOf(o1: string, o2: string, stackNbr1 : number, stackNbr2 : number) : number {
                return hueristicLeftOf(o2, o1, stackNbr2, stackNbr1)
            }

            function objecsToMoveInStack(object: string, stack : string[]) : number{
                var objsToMove : number = 1
                //if (!stack) { return 0}
                var tempStack = stack.slice(0) //Make a copy
                for(var i = 0; i < stack.length; i++) {
                    tempStack.push(object) //add object to the stack
                    if(!graph.isValidStack(tempStack)) {
                        objsToMove++
                        tempStack.pop()
                        tempStack.pop()
                    } else {
                        break
                    }
                }
                return objsToMove
            }


        }


        function goalFunction(interp : Interpreter.DNFFormula, n : StateNode) : boolean {
            var satisfied = false
            interp.forEach((conjuction : Interpreter.Literal[]) => {
                var conjuctionSatisfied : boolean = true
                conjuction.forEach((lit : Interpreter.Literal) => {
                    conjuctionSatisfied = conjuctionSatisfied && literalFullfilled(lit, n)
                })
                satisfied = satisfied || conjuctionSatisfied
            })
            return satisfied
        }

        function literalFullfilled(lit : Interpreter.Literal, n : StateNode) : boolean {
            var a = findObjPos(lit.args[0], n)
            var b = findObjPos(lit.args[1], n)
            var isFloor = lit.args[1] == "floor"
            if (a[0] == -1 || a[1] == -1 || ((lit.args[1] && !isFloor)
                                             && (b[0] == -1 || b[1] == -1))) {
                return false
            }
            var result : boolean = false
            switch (lit.relation) {
                case "holding":
                    result = a[1] == n.data[a[0]].length - 1
                    shouldHold = lit.args[0]
                    break
                case "ontop":
                    if (isFloor) {
                        result = a[1] == 0
                    } else {
                        result = a[0] == b[0] && a[1] == b[1]+1
                    }
                    break
                case "inside":
                    result = a[0] == b[0] && a[1] == b[1]+1
                    break
                case "under":
                    result = a[0] == b[0] && a[1] < b[1]
                    break
                case "above":
                    if (isFloor) {
                        result = a[1] >= 0
                    } else {
                        result = a[0] == b[0] && a[1] > b[1]
                    }
                    break
                case "beside":
                    result = Math.abs(a[0] - b[0]) == 1
                    break
                case "leftof":
                    result = a[0] - b[0] == -1
                    break
                case "rightof":
                    result = a[0] - b[0] == 1
                    break
            }
            return result
        }

        function findObjPos(obj : string, n : StateNode) : [number, number] {
            var stacks = n.data
            for (var i = 0; i < stacks.length; i++) {
                var j = stacks[i].indexOf(obj)
                if (j > -1) {
                    return [i, j]
                }
            }
            return [-1, -1]
        }

        function planBetweenStates(s1 : StateNode, s2 : StateNode) : string[] {
            var from = s1.data
            var to = s2.data
            var picStack = 0
            var putStack = 0

            //Get the stacks an object will move from and to
            for (var i = 0; i < from.length; i++) {
                if (from[i].length > to[i].length) {
                    picStack = i
                }
                else if (from[i].length < to[i].length) {
                    putStack = i
                }
            }
            //Move the arm to the stack the object will move from
            var moveDir = arm < picStack ? "r" : "l"
            var iterations = Math.abs(arm - picStack)
            for (var i = 0; i < iterations; i++) {
                plan.push(moveDir)
                arm = arm +(moveDir == "r" ? 1 : - 1)
            }
            //Move the object to the stack it will get to
            var obj = from[picStack][from[picStack].length-1]
            plan.push("Picking up the " + state.objects[obj].form, "p");
            moveDir = picStack < putStack ? "r" : "l"
            plan.push("Moving arm " + (moveDir == "r" ? "right" : "left"))
            var iterations = Math.abs(picStack - putStack)
            for (var i = 0; i < iterations; i++) {
                //console.log(moveDir)
                plan.push(moveDir)
                arm = arm + (moveDir == "r" ? 1 : -1)
            }
            plan.push("Dropping the " + state.objects[obj].form, "d")

            return plan
        }

        function pickUpObj(s : StateNode) : string[] {
            var to = findObjPos(shouldHold, s)[0]
            var moveDir = arm < to ? "r" : "l"
            var iterations = Math.abs(arm - to)
            for (var i = 0; i < iterations; i++) {
                plan.push(moveDir)
                arm = arm +(moveDir == "r" ? 1 : - 1)
            }
            //Move the object to the stack it will get to
            var obj = s.data[to][s.data[to].length-1]
            plan.push("Picking up the " + state.objects[obj].form, "p");

            return plan
        }

        function planPutDownHolding(s : StateNode) : string[] {
            var to = findObjPos(holding, s)[0]
            var moveDir = arm < to ? "r" : "l"
            var iterations = Math.abs(arm - to)
            for (var i = 0; i < iterations; i++) {
                plan.push(moveDir)
                arm = arm +(moveDir == "r" ? 1 : - 1)
            }
            //Move the object to the stack it will get to
            var obj = s.data[to][s.data[to].length-1]
            plan.push("Dropping the " + state.objects[obj].form, "d")

            return plan
        }
    }
}
